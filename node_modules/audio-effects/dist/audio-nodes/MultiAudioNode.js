"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var SingleAudioNode_1 = require('./SingleAudioNode');
/**
 * The multi-audio-node class.
 * When creating an effect existing out of multiple audio-nodes, we can wrap it in this class.
 * You can set the input node (effect.node) and the output node of the effect (effect.output).
 * The input node is the first audio-node in the effect, the previous effect will be connected to this node.
 * The output node is the last audio-node in the effect, the next effect will be connected to this node.
 */
var MultiAudioNode = (function (_super) {
    __extends(MultiAudioNode, _super);
    function MultiAudioNode(audioContext) {
        _super.call(this, audioContext);
    }
    Object.defineProperty(MultiAudioNode.prototype, "output", {
        /**
         * Getter for the effects output node.
         * @return {AudioNode}
         */
        get: function () {
            return this._outputNode;
        },
        /**
         * Setter for the effects output node.
         * @param  {AudioNode} output
         * @return {AudioNode}
         */
        set: function (output) {
            this._outputNode = output;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Connect the effect to other effects or native audio-nodes.
     * @param  {AudioNode|SingleAudioNode|MultiAudioNode} node
     * @return {AudioNode|SingleAudioNode|MultiAudioNode}
     */
    MultiAudioNode.prototype.connect = function (node) {
        // Check if the node is one created by audio-effects
        //  otherwise assume it's a native one.
        if (node.node) {
            this.output.connect(node.node);
        }
        else {
            this.output.connect(node);
        }
        return node;
    };
    /**
     * Disconnect the effect.
     * @return {AudioNode}
     */
    MultiAudioNode.prototype.disconnect = function () {
        this.output.disconnect();
        return this.output;
    };
    /**
     * Destroy an effect.
     * @return {AudioNode}
     */
    MultiAudioNode.prototype.destroy = function () {
        var _this = this;
        Object.keys(this.nodes).forEach(function (node) {
            if (_this.nodes[node].disconnect && typeof _this.nodes[node].disconnect === 'function') {
                _this.nodes[node].disconnect();
            }
        });
        return this.disconnect();
    };
    return MultiAudioNode;
}(SingleAudioNode_1.SingleAudioNode));
exports.MultiAudioNode = MultiAudioNode;
;
