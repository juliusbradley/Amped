"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var SingleAudioNode_1 = require('../SingleAudioNode');
var hasGetUserMedia_1 = require('../../helpers/hasGetUserMedia');
/**
 * The audio-effects input node.
 * This class lets you set an input audio source or access the  uses' microphone.
 */
var Input = (function (_super) {
    __extends(Input, _super);
    function Input(audioContext) {
        _super.call(this, audioContext);
        this._deferredConnects = [];
        this._hasPermissions = false;
    }
    Object.defineProperty(Input.prototype, "input", {
        /**
         * Getter for the effects input node.
         * @return {AudioNode}
         */
        get: function () {
            return this.node;
        },
        /**
         * Setter for the effects input node.
         * @param  {AudioStream} stream
         */
        set: function (stream) {
            // Create a media-stream source.
            this.node = this.audioContext.createMediaStreamSource(stream);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get your microphone sound as input.
     * @return {Promise<AudioNode>} Resolves when you accept to use the microphone.
     */
    Input.prototype.getUserMedia = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (hasGetUserMedia_1.HasGetUserMedia) {
                navigator.getUserMedia({
                    audio: true
                }, function (stream) {
                    _this.input = stream;
                    _this._hasPermissions = true;
                    // Connect the deffered connects
                    _this._deferredConnects.forEach(function (node) {
                        _this.connect(node);
                    });
                    resolve(stream);
                }, function (error) {
                    reject(error);
                });
            }
            else {
                reject('Your browser does not support the use of user-media, please upgrade or use another browser!');
            }
        });
    };
    /**
     * Connect the effect to other effects or native audio-nodes.
     * @param  {AudioNode|SingleAudioNode|MultiAudioNode} node
     * @return {AudioNode|SingleAudioNode|MultiAudioNode}
     */
    Input.prototype.connect = function (node) {
        // If there is no input node yet, connect when there is a node
        if (typeof this.node === 'undefined') {
            this._deferredConnects.push(node);
            return node;
        }
        // Check if the node is a Audio-effects AudioNode,
        //  otherwise assume it's a native one.
        if (node.node) {
            this.node.connect(node.node);
        }
        else {
            this.node.connect(node);
        }
        return node;
    };
    /**
     * Get a list of audio in-and-output devices devices.
     * @return {Promise<Array<any>>} A list of the available audio in-and-output devices.
     */
    Input.prototype.getAudioDevices = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this._hasPermissions) {
                navigator.mediaDevices.enumerateDevices().then(function (devices) {
                    resolve(devices.filter(function (device) {
                        return device.kind && device.kind === 'audioinput';
                    }));
                }).catch(function (error) {
                    reject(error);
                });
            }
            else {
                _this.getUserMedia().then(function () {
                    navigator.mediaDevices.enumerateDevices().then(function (devices) {
                        resolve(devices.filter(function (device) {
                            return device.kind && device.kind === 'audioinput';
                        }));
                    }).catch(function (error) {
                        reject(error);
                    });
                }).catch(function (error) {
                    reject(error);
                });
            }
        });
    };
    return Input;
}(SingleAudioNode_1.SingleAudioNode));
exports.Input = Input;
;
